[Tutsgalaxy.com] - Mastering Advanced C Programming Pointers (In Depth)

__________________________________________________________________________________________________________________________________________________________

S1E1

By Ravi kishore

	==>data variables and pointer variables

		==>pinter variable==>holds address of same type of data

		==>size of pointer will be same as architecture of processor


__________________________________________________________________________________________________________________________________________________________

S1E2

int a

		//garbage value is like junk value

int *p  ==>* is for defining a pointer variable

p = &a

__________________________________________________________________________________________________________________________________________________________

S2E1

	doc

__________________________________________________________________________________________________________________________________________________________

S3E1

	single pointer
===============================
	#include<stdio.h>

	int main(){
		int a = 10;
		int *p;
		p =&a;
		printf("a = %d, p=%x, &a=%x, *p = %d\n", a, p, &a, *p)
		return 0;
	}

	================

	gcc file_name.c

	>>./a.out


__________________________________________________________________________________________________________________________________________________________

S3E2

c supports 12 level of pointer ==>like nesting pointer

int **q ==>two level pointer, it is defining

*(***r)  ===>it is two access like this


__________________________________________________________________________________________________________________________________________________________

S3E4.5

practical

__________________________________________________________________________________________________________________________________________________________

S4E1

Lvalue and RValue 

	lValue at compile time==>represents address

	rValue at runtime==>represents value


__________________________________________________________________________________________________________________________________________________________

S5E1.7

	type needs to be matched, as we can inrement pointers too



__________________________________________________________________________________________________________________________________________________________

S6E1.8


Arithmetic operations in pointers

	+,-,*,/

	==>performed in same type of pointers

	segmentation faults ===>when resultant address is not there in memory(after performing arithmetic operations)

	p1 * p2 and p1/p2  ==>is not poosible
	
	==>p + 1*(size of ptr)

	
__________________________________________________________________________________________________________________________________________________________

S7E1.9

	pre and post increment of pointers

	int a[3] = {10,20,30};

	int *p =a;

	res = *p++;  //increment to pointer and we will get incremented address

		=*++p // in this we will get value of incremented pointer

		=++*p //we will get incremeted value

__________________________________________________________________________________________________________________________________________________________

S7E2.10

	int main(){
	
	int a[3]={10,20,30};
	int *p;
	int res = -1;
	p =a;

	res = *p++; //result is incremented pointer
	res =*++p; //result is 20
	res = ++*p; //res eill be 11

	}
		
__________________________________________________________________________________________________________________________________________________________

S8E1.11

generic pointers

	==>earlier we had same pointers

		==>no mis match allowed earlier

	==>generic pointer is compatible with any type of data

	==>it is represented with void*

	==>it only knows how many bytes of address is using

==================================
	int arr[5]={10,20,30,40,50};

	void *p;

	p=arr; // here it does not know what type of data it is holding, but it knows that it have 20 bytes as size of array


	printf("%d",*p) //error

			==>now we need to type cast 

	printf("%d",*(int*)p) ==>//we type casted and then retrieving

	===================

	dereferencing ==>is getting the value from pointer

	==>no data loss using generic pointer, no extra memory needed

	==========================================
	int main()
	{
		int a = 10;
		float f = 4.8;

		void *p;

		p =&a;
		printf("a =%d ",*p); //wwe will get error
		printf("a =%d ",*(int *)p); // now we will get the value
		printf("a = %d\n",*(char *)p); //it will print 0, as its knowing that it holds one character
			//if int a =257 // then it will give 1, if we try to get value from char pointer type

		return 0;
	}


__________________________________________________________________________________________________________________________________________________________

S9E1.12

null pointer

	===>PAS ==>process address space is given by OS, every time program starts

	==>segments that process have

		==>code segment
			===>text section
			==>instruction

		===>Data segment
			==>.data section (initialised memory for static and global variables)
			==>.bss section (uninitialised, default initialised to 0)

		==>Stack segment
			==>Stack section(used for program execution & memory for local variables)
			==>Heap section (runtime memory allocation)

			
==>when program crosses PAS, we get segmentation fault

__________________________________________________________________________________________________________________________________________________________

S10E1.13

	significance of initialisation of pointer to null

		==>if it is not initialised with null we will get some different value
			or we will get segmentation fault

		int *p = (int *)0;

		or

		int *p = (void *)0;

		#define (void*)0 NULL

			==>now  we will ger NULL pointer dereferenced

__________________________________________________________________________________________________________________________________________________________

S10E2.14

	vi nullpointer.c

	#include<stdio.h>

	int main(){
	
		int a; //garbage value
		int *p; //garbage value

		printf("a= %d, p=%u",a,p);
		

		return 0;
	}



__________________________________________________________________________________________________________________________________________________________

S11E1.15

contant pointers

 const char *p; ==> pointer can be updated, data can not

 char const *p; ==>pointer can be updated, data can not

 char * const p; ==> data can be updated, pointer can not

 const char * const p; ==> pointer can not be updated,also data can not


## think it like char word is not there

__________________________________________________________________________________________________________________________________________________________

S11E2.16

main(){

char arr[4] = {'A', 'B', 'C'};
const char *p = NULL;
return 0;

char * const p; //ptr is constant but *ptr is not constant


}

////>>> gcc filename.c
>>>./a.out

__________________________________________________________________________________________________________________________________________________________

S12E1.17

Allocate memory dynamically

	//stack memeory is for static memory
			
			==>local variables
			==>Heap Section

	//heap section is for dynamic memory
			


__________________________________________________________________________________________________________________________________________________________

S12E2.18

whenever main function gets called

	==>stack segment comes into picture

		==>stack section
			==>it has more memory in whole stack segment

		==>heap section
			==>we will get the base address of heap , and will store in stack section

			==>we have to free all the written data in heap, and it will not be used as OS will think it is attached to some process

			==>So we have to free in heap, as only stack gets released by OS after completeion of pgm


__________________________________________________________________________________________________________________________________________________________

S12E4.19


function to allocate dynamic memory 

	void* malloc(size_t size);

		==>will allocate in sequence

		==>on success, will give return address (generic address , needs to be type casted)
		
		==>on failure , return NULL



__________________________________________________________________________________________________________________________________________________________

S12E5.20

#include<stdlib.h> //else you will get warning

	in malloc ==>new created memory will not be initialised

	main(){
	
	char *p = NULL;
	//hello
	p = (char *) malloc(6*sizeof(char));
	//above stmt will create 6 block of m/m in heap

	if (p==NULL){
		printf("memory allocation using malloc failed\n");
		return -1;
	}else{
		printf("m/m allocation success\n");
	}
	
	char *p1=p;

	*p ='h';
	++p;
	*p ='e';
	++p;
	*p ='l';
	++p;
	*p ='l';
	++p;
	*p ='o';
	++p;
	*p='\0';

	printf("data stored in dynamic memory is %s\n", p1); // we will get all characters

	free(p1); //now it will maintain all the m/m from base address
	//*p1; // now we have released it from our program

	return 0;
	}

//valgrind ==>is tool to find memory leaks

>>>valgrind --tool=memcheck --leak-check=yes ./a.exe


__________________________________________________________________________________________________________________________________________________________

S12E7.21

calloc (sixe_tnum_elements,size_telement_size)
	
	//in this case we dont have multiply how many char we need
	// as it asks while calling
	//also it initialises , every byte with 0 in case of int, and '\0' in case of char
 
	// it also returns void * ===>generic pointer , hence we need to type cast
===========================================
	//hello
	char *p;
	p = (char *) calloc (6, sizeof(char));
	
	// if p is NULL , m/m allocation failed



__________________________________________________________________________________________________________________________________________________________

S12E9.22


*realloc(void *ptr, size_t_new_size)
	
	// first parametr is base address from where we need to make change
	==>extend or reduce the existing memory in heap

	//like we have 5 blocks earlier
	
	realloc(base_addr, 10*sizeofc(char))

		//==>it will return void*, then we need to type cast

		// if it is possible
		//if not possible, then it tries to get some other location, and copy old m/m to new blocks
			//and in this case, it will be freed by realloc automatically, and it will return new address
		
		===================

		now if not able to extend anywhere our request,
			//in case of failure it will return NULL, otherwise we would have gotten some address
			// and also we will lose the refernce, and there is memory leak
				// in that case experiment with othercase in case of realloc

//problem of above solution and in case we are not able to proceed
		if(p1==NULL){
			free(p);
			return -1;
		}
			

===>realloc also used reduce the allocated m/m

earlier 

ptr = (int *) malloc (2*sizeof(int)); //i.e we have asked for 8 bytes

now

ptr = (int *)realloc(ptr,4);

//if base address is null, then it is equivalent to malloc

if size is 0 ==>then it is like free(ptr)


__________________________________________________________________________________________________________________________________________________________

S12E10.23

#include<string.h>

if (p ==NULL){
printf("failure state")
}

strcpy(p, "hello");

//requirement for increase to 10 bytes

	char *p1 =NULL;
	p1=(char *)realloc(p,10*sizeof(char));
	
	if(p1==NULL){
		printf("realloc failder")
		free(p);
		return -1;
	}else{
		printf("realloc is successfully allocated new memory\n");
		p=p1;

	}

strcpy(p,"helloravi");

printf("p=%p",p);


__________________________________________________________________________________________________________________________________________________________

S13E1.24

Memory leak
	==>memory is existing but pointer is not there
	


Dangling refernce
	==>memory is not there but refernce is still there, even after free the memory with some other refernce
	==>we should avoid of copying the pointers
			==>instead we could copy the same data in some other ptr at some other location

what have we discusser

	===>pointers
	==>level of pointers
	==>lvalue and rvalue
	==>arithmetic operations with pointers
	==>generic pointers and casting of pointers
	==>NULL pointer
	==>pointers with constant
	==>Dynamic memory allocation
		==>malloc
		==>calloc
		==>realloc
	==>free(address)


		...done















