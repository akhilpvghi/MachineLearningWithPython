Learn C Sharp from scratch to advance level

	by Sajid amin mughal
__________________________________________________________________________________________________________________________________________________________

S1E1

	history of C#

	syntax

	assignment

	control action

	switch and jump

	access modifier

	OOps

	inheritance

__________________________________________________________________________________________________________________________________________________________

S1E2

	C# by microsoft in june 2000

	==>similar to C++ and java

	==> more primitive data dypes

	==>safer enumeration types

=======

google.com

	microsft visual studio


	=======

	static void main(String[] args){
		
		Console.WriteLine("Hello world!! this is my first program");
		Console.ReadLine();
	}
	

__________________________________________________________________________________________________________________________________________________________

S1E3

	compiler setting to run programs


	environment variable set

__________________________________________________________________________________________________________________________________________________________

S1E4

using System;
class Hello{
	static void main(){
		Console.writeLine("Hello World !! this is my 1st program in C sharp");
	}
}
=============	
cmd

>> csc pgm_name.cs
>>pgm_name

//it is purely object oriented
__________________________________________________________________________________________________________________________________________________________

S2E6

	Data types in C#

	predefined data types(DT)

		==>boolean

		==>numeric DT
			
			==>floating

			==>integral
				==>signed 
				==>unsigned

			==>decimal
		
		==>character
	
===========================================

use System;

class Datatype{
	static void main(string[] args){
		int a, b;
		Console.WriteLine("integer calue of a and b",a+b);  //23
	}
}

if float
//a=2.3f
//b=3.6f

//otherwise do double


__________________________________________________________________________________________________________________________________________________________

S2E7

type casting
	
	==>implicit type casting
		==>by compiler itself
		e.g. int to float
	==>explicit type casting
		==>its done by user
	
int a= 20;
float b=a;

	//will run fine, as it is implicit, small DT to Large DT

==========================

float a= 20.5f;
int b=a; //error

int b=Convert.ToInt32(a); //20

============
char a='2';
int b =Convert.ToInt(a); //not checked

========================
__________________________________________________________________________________________________________________________________________________________

S2E8



	



		.....incomp
	

=====================================================================================================================================================

C Sharp and Visual Studio 2017 Create your first apps


__________________________________________________________________________________________________________________________________________________________

S1E1


	Intro
__________________________________________________________________________________________________________________________________________________________

S2E2

	what is .Net

		==>.Net framework ==>web service strategy 

		==>gives ability to C# to build application fast

__________________________________________________________________________________________________________________________________________________________

S2E3

	what is C#?

		==>main pgms language for .Net framework

		==>based on C programming language

		==>similar to C++ and java

		==>create application for desktop, mobile , web application


__________________________________________________________________________________________________________________________________________________________

S2E4


	==>video not working 
	
__________________________________________________________________________________________________________________________________________________________

S2E5

	==>different object

	==>class  ==> blueprint


__________________________________________________________________________________________________________________________________________________________

S2E6

	variables 

		==>identifier

__________________________________________________________________________________________________________________________________________________________

S2E7	

	methods 
		==>to talk to object
		==>object presents interface to outside world
__________________________________________________________________________________________________________________________________________________________

S2E8

Inheritance in programming

	is a relationship ==> Inheritance

__________________________________________________________________________________________________________________________________________________________

S2E9

	Encapsulation in programming

		budling of methods

		==>like off button in calculator

		==>and we dont know about inner structure

__________________________________________________________________________________________________________________________________________________________

S3E10


	==>download visual studio official site

		==>visual studio community

			==>free download
			
			check all this in workloads
				==>universal window platform development
				==>.Net desktop
				==>ASP.net and web development
				==>azure
				==>data storage
				==>mobile development
				
__________________________________________________________________________________________________________________________________________________________

S3E11

	==>restart system while installation everytime it asks

	==>development setting ==>general

	==>color theme ==> dark
			
__________________________________________________________________________________________________________________________________________________________

S3E12

change setting of visual studio

	==>tools

		=>>options

			==>environment

				==>can change theme

		==>text editor

			==>all languages

				==>line number should be checked

			
__________________________________________________________________________________________________________________________________________________________

S4E13

	Basics of C#

			
__________________________________________________________________________________________________________________________________________________________

S4E14
	
	==>file

		=>new 

			==>project

		==>C#
			==>windows

				==>windows Forms application

	
================

view
	==>tool box

	==>property window

	==>solution explorer

==>drag_n_drop



		.....incomp
==================================================================================================================================================

==================================================================================================================================================

\[FreeAllCourse.Com] Udemy - C# Intermediate Classes, Interfaces and OOP

	by Mosh Hamedeni
__________________________________________________________________________________________________________________________________________________________

S1E1

	intro

	==>interfaces are not to create multiple inheritance solely

	==>interface improves extensibility


__________________________________________________________________________________________________________________________________________________________

S1E2

	About Instructor

__________________________________________________________________________________________________________________________________________________________

S2E1

	Introduction to classes

		==>building block of softwarae

			==>each responses for particular behavior

	Anatomy of a class (inside class)

		==>data

		==>methods/functions

	Object 
		==>An instance of class

====================

public class Class_name{  //class name is identifier==>pascal for class
	
	public string Name;  // in real donot declare it with public

	public void Introduce(){
	
		COnsole.WriteLine("hello"+ Name);

	}
}
	

=======================

clas_name object_name = new CLass_name();

var object_name = new Class_name(); //now compiler knows its of same class

	===>class Members

		==> Instance

		==> Static
	
			static is used when member is always same , like date and time, writeLine

===============================================

namespace Classes

{

	public string Name;

	public void Introduce(strint to){
		Console.WriteLine("Hi {0}, I am {}",to, Name);
	}

	public Person Parse (string str){
	var person = new Person();
	person.Name = str;

	return person;
	}

	class Program{
		static void Main(string[] args){
		var person = new Person();
		person.Introduce("Akhil");
		}
	}

}

__________________________________________________________________________________________________________________________________________________________

S2E2

Constructor

	==>to put object in initial state

	public class Class_name{
		
		public string Name;
		public Classs_name(string name){  //does not have return type
		
		this.Name = name;
							// the invisible parameter set values to default like int to 0
		}

	}


===========

construtor overloading is there in C#

	==>different signature
	===>so that makes initialissation easy, sometime we may not know all the parameters

========================

namespace Anything

{
	public class Customer{
		
		

		public List<another_Class_name> another_Class_name;
		
			public Customer(){
				Orders = new List<Order>();  // otherwise we would not be able to add something in that list, nothing can be added to null referenced 
			}                                    //we always need to make sure thar list is initialised
						// but what if we want to use with anothre overloaded constructor, do we really need to initialise it in every construcor...?
							==>solution is this key word

			public CUstomer(int id)
				: this()         //now very time this constructor gets called, it will first call , constructor with no paramets and then list of orders will be initialised
			{
				this.Id = id;
			}
		
			//code snippet ==>cw then tab ==>shortcut 
			//f9 ==>to set debugger
			//f5 to debug
			//shift + f5 ==>to stop debug
			//ctrl+tab ==>to go to classes
			//ctor ==>code snippet ==>short cut ==>then tab

		public Customer(int id){
			this.Id =id;
		}

		
			// we only create constructor when we need default values
			//
	}
}


// always initialise list to some default value


var customer = new Customer();
Console.WriteLine(customer.id);

=============


	// when we create custom constructor , compiler does not detect default connector


__________________________________________________________________________________________________________________________________________________________

S2E3


object initialiser

	var person = new Person
			{
				FirstName ="Mosh",
				LastName = "Hamedani"
			};

		// in this case object will be initialised with having  structure of constructor in that way



__________________________________________________________________________________________________________________________________________________________

S2E4

	methods

		==>signature
				==>name, no of parameter , type of parameter
				
						

		==>method overloading
				public int Add(int[] numbers){}  // to avoid overloading
					===================
						var result = Calculator.Add(new int[]{1,2,3,4});

							//in this case we have to initialise, new integer array again and again

							// to reslove that we can add params modifier

							public class Calculator{
								public int Add(params int[] numbers){}
							}

							//now

							var result = calculator.Add(new int[]{ 1,2,3,4});
							var result = calculator.Add(1,2,3,4);
	
							// both cases are acceptable with params modifier
							
							


		==> params modifier

		==>ref modifier

			public void fn_name(ref int a){
				a+=2;
			}


			var a=1;
			class.fn_name(ref a);  //now it is like sharing address and works as global

		==>out modifier

			public void method(out int result){
				
				result =1;
			}


				//
				int a;
				class.method(out a);

					// out modifier can return a more than one value

					
						//select class name ==>alt + enter ===>and it will move to the next file
					public void Move(point newLocation){
				if (newLocation == null)
					throw new ArguementNullException("newLOcation");  //it is known as defensive programming
					}

					//try ==>tab ==>code snippet
					
							try{
							
							}
							catch(Exception){
							
							Console.WriteLine("an exception occured");


							}


							=================

							public int Add(params int[] numbers){
							
							var sum =0;
							foreach (var number in numbers){
							
							sum+=number;
							}
							return sum;



							}


		=================

		main(........){

			var calculator = new Clculator();
			Console.WriteLine(calculator.Add(1,2,3......));


		}

=============================================================================



	main(............){

		var number = int.parse("abc");
		// we will get exception
		int number;
		var result = int.TryParse("abc", out number);
		if (result)
		Cw(number)
		else	
			cw("conversion failed");
	}


__________________________________________________________________________________________________________________________________________________________

S2E5

Fields

	fields is variable at class level

	==>initialisation

		{

			List<Order> orders = new List<Order>(); 
		}


	==>read only fields


	
			readonly List<Order> orders = new List<Order>();

					// it will be created only once
					// can not be reinitialised



=======================================================================================

	public class Customer{

		public int Id;
		public string Name;
		public readonly List<Order> Orders = new List<Order>();
	}

	public Customer(int id){

		this.Id = id;
	}
	
	pubic Customer (int id, string name)
		: this(id){

			this.Name = name;
		}
									
public void Promote(){

		 Orders = new List<Order>(); // now we will get error as it is read only now
												//now this line is not acceptable
}				

}

===========================================

main(.........){

	var customer = new Customer(1);
	customer.Orders.Add(new Order());
	customer.Orders.Add(new Order());

	cw(customer.Orders.Count);
	
}

	publci class Order{


	}


__________________________________________________________________________________________________________________________________________________________

S2E6


	Access modifier : way to control access to class and its members

				PIE  ==>encapsulation we will be talking

						===> getters and setters

						if(!String.IsNullOrEmpty(name))

						//private field starts with _(underscore)



		public

		private

		protected

		internal


		protected internal


=========================

public class Person{

	private DateTime _birthdate;

	public void SetBirthdate(DateTime birthdate){

		_birthdate = birthdate;
	}

	public DateTime GetBirthdate(){

		return _birthdate;
	}

}

==========================================


main(..........){

	var person = new Person();
	person.SetBirthdate(new DateTime(1982, 1, 1));
	cw(person.GetBirthDate());

}



	///their fields are internal and should be hidden outside world




__________________________________________________________________________________________________________________________________________________________

S2E7


Properties

	==>property 

		==>to create getter and setter

		==========================================

		private DateTime _birthdate;

		public DateTime Birthdate
		{
			get{return _birthdate; }
			ser {_birthdate = value; }

		}

==========================================================================

auto implemented properties

public class Person{

	public DateTime Birthdate { get; set; }
	public int Age {

		get {
		var timeSpan = DateTime.Today - Birthdate;
		var years = timeSpan.Days/365;

			return years;
		}
	}
}

// this will create private fiels and cretae getter and setter
==================================================================

 ===>open command prompt in visual studio===>if we dont have it open , visual studio productivity tool

 ====>go to tools 

	==>extension amd update

		==>online

			==>search box type productivity power tool


===>right click to namespace and open command prompr


cd bin

cd Debug

ildasm Properties.exe     //il diassembler


=========================================================================================


Main(......){

	var person = newPerson();
	person.Birthdate = new DateTime(1982, 1, 1);
	cw(person.Age);
}


	///what if we want to set field only once 



			///now birth date can only be set once that is in constructor

	public DateTime Birthdate { get; private set;}
	public Person(DateTime birthdate){

		Birthdate = birthdate 
	}

	   ///with private its only read and can be changed in constructor once


	//prop ==>tab ==>code snippet

	.....now Main(...){

		var person = new Person (new DateTime (1982,1 ,1));
		cw(person.Age);
	}





__________________________________________________________________________________________________________________________________________________________

S2E8


Indexers

	==>way to access

	var array = new int[5];
	array[0] = 1;

	var list = new List<int>();
	list[0] = 1;

	==================================================================

	var cookie = new HttpCookie();
	cookie.Expire = DateTime.Today.AddDays(5);

	cookie["name"] = "Mosh";
	cookie.SetItem("name","Mosh");

	=================================================

public class HttpCookie{

	private Disctionary<string, string> _dictionary;

	public HttpCookie(){

		_dictionary = new Dictionary<string, string>();
	}

	public string this[string key]{
		get { 
			return _dictionary[key];
		}
		set {
			_disctionaru[key] = value;
		}

	}


}
===============================================

main(......)
cookie["name"] = "mosh";
cw(cookie["name"]);



__________________________________________________________________________________________________________________________________________________________

S3E1

class coupling

	==>what if we want to change the name of the class

		tightly coupled ==> when dependency is more

		loosely coupling ==>

			but how
				
				=>encapsulation

				==>the relationship between classes

				==>Interfaces


Types of  relationship

	==>Inheritance

	==>Composition

==>Favor composition over Inheritance

__________________________________________________________________________________________________________________________________________________________

S3E2

	What is inheritance

		==>is-A

		==>inherit code from another

		==>we get code re-use

		==>we get polymorphic behaviour

UML representation

	==>we need to figure out common behaviour

=================================

public class Parent

{

}


public class Child_class : Parent_class{

}

================================================================================================================

Main(....){

var text = new Text();
}


__________________________________________________________________________________________________________________________________________________________

S3E3

	Composition

		==>Has-a relationship

		==>we get code re-use

		==>more flexible

		==>e.g DbMigrator requires logging

			==>installer requires logging

	UML representation with composition ==>represented by black diamond

	=====

	syntax

	public class Installer

	{
		private Logger _logger;

		public Installer (LOgger logger){
			
			_logger = logger;
		}
	
	}                              //ctor ==>tab==>and constructor will be generated

	===>//we declare common functionality, in same


__________________________________________________________________________________________________________________________________________________________

S3E4

Favor composition over inheritance

	problem with inheritance

		==>easily abused by mature developers

		==>large hierarchy

		==>fragility

		==>tightly coupling


Benefits of Composition

	==>great flexibility

	==>Loose coupling

		==>we can create class to Interface in composition


__________________________________________________________________________________________________________________________________________________________

S4E1 (INHERITANCE - 2nd pillar of OOP)

	Access modifiers

		==>why they are important

		==>Blackbox metaphor

		=>types

			==>public
				
				==>can access from anywhere
				==>like promote function
			==>private
				==>is only accessible from that class

			==>protected
				===>is accessible from class andd its derived class
			
			==>internal
				==>interanal class Class_name

					==>accesible only from same assembly


				
			
			==>protected internal
					==>access  from same assembly and derived class

============================================================
		// bool some_var;


calling_of_functions(var_name: true);
=========================================================================

	//alt+enter ==>to get class in new file
=========================================================================

using another_namespace;

Main(...){
another_namespace.class object = new clas();   //internal class can not be accessed
}


__________________________________________________________________________________________________________________________________________________________

S4E2

Constructor and inheritance

	==>base class executed first

	==>base class constructor are nor inherited

	child constructor()
		:base(arguement)
	{}

	//parent and child constructor should match parameterization



__________________________________________________________________________________________________________________________________________________________

S4E3

upcasting and downcasting

	==>conversion of derived to parent class and vice versa

		///InvalidCastException

		//as and is keyword


=========================================

public class Shape{
	public int WIdth { get; set; }
	
	public int Height { get; set; }
}


public class Text: Shape{
	
	public int fontSIze;
}

Main(...){
Text text = new Tex();
Shape shape = text;

	// this is upcasting, they are referncing to same object
}

========
view ==>object browsee
======
using System;
using System.IO;

Main(...)
{
	StreamReaderreader = new StreamReader(new MemoryStream());

	ArratList list = new ArrayList();
	list.Add(1);
	list.Add("Mosh");

	var anotherList = new List<int>(); //generic class

	shape shape = new Text();
		//f9 to put break point
		//f5 to run debug
	Text text = (Text) shape; // downcasting

	//WPF project for desktop application
	

}
__________________________________________________________________________________________________________________________________________________________

S4E4

Boxing and unboxing

	==>value types 

		primitive===> byte, int, float, char

	==>reference type

		==>stored in heap
		==>any class, object

		//typecasting

__________________________________________________________________________________________________________________________________________________________

S5E1

method overriding

	==>overide in child class

	public class Circle : Shape{
	
	public override vod Draw(){
	
	}
	
	}
===================================================

public enum ShapeTYpe{
	Circles,
	Rectangles,
	Triangles
}

===============================

public class Circle : Shape{
}


public class Rectangle : Shape{
}

public class Shape{
	
	public int Width { get; set; }
	public int Height { get; set; }
	public Position Position { get; set; }
	
	public virtual void Draw(){ // virtual will aloow to override in child class
	
	}

//base.Draw() // can be called to call parents method


	
}
==========================================

public class Canvas {
	
	public void DrwShapes(List<SHapes> shapes){
		foreach (var shape in shapes){
			shape.Draw();
		}
	}
}
====>
this will allow flexibility to add new shapes

	==>this is what we call loosely coupling
__________________________________________________________________________________________________________________________________________________________

S5E2

	Abstract class and modifiers

	Abstract modifier

		==>when we dont know the implementation

		public abstract class Shape{
			
			public abstract void Draw(); 
		}
	
		//abstract method needs to have in abstract class and needs to be implemented in child class

		==>abstract method do not include body

		==>child class needs to implement all abstract method of parent class

		==>abstract class can not be intianiated

		==>we use abstract to follow common behaviour

			==>we have to leave method empty in parent abstract class==>curly braces will not be there

	=====================

	namespace Absract{
	
	public abstract class shape{
	
	//it can have abstract as well as non abstract methods

	// but this class can not be intianted , can only be used(non abstrac methods) via child instnces
	} 

	}


//stream class is abstract class
__________________________________________________________________________________________________________________________________________________________

S5E3

sealed class and members

	sealed modifier (like final key word in java)

		==>if applies to method , can not be overridden

		//very less use

		//but faster

__________________________________________________________________________________________________________________________________________________________

S6E1

Interface
	
	==>declare 
	==>Implementation
	==>benefits

===================================

public interface ITaxCaluclator{

	int Calculate();
}


	//Interface starts with I in C#
	//they do not have implementation
	//they do not have access modifiers
	//to build loosely coupled
	==>improves the testability and extensibility
	//similar to systax of class
	//components are not tightly related to eacg other



__________________________________________________________________________________________________________________________________________________________

S6E2

interface improves the testability

//in main function we are passing the helper class , which is accepted as Interface instance, and that interface is implemented by the sae class that we 
	passed in main, and using instance of that interface, we are calling required function
// when interface function is implemented in another class, it has to be public only

__________________________________________________________________________________________________________________________________________________________

S6E3

interface improves the extensibility



public class ConsoleLogger : ILogger{

public void LogError(string message){
	
	Console.ForegroundColor = ConsoleColor.Red;
	Console.WriteLine(message)
}


public void LogError(string message){
	
	Console.ForegroundColor = ConsoleColor.Green;
	Console.WriteLine(message)
}

}



	 class Dbmigrator 
	 

{

		private readonly ILogger _logger;

		public DBMigrator(ILogger logger){
			_logger = logger
		}

		public void Migrate(){
	
		_logger.LogInfo("migrating started at {0}"+DateTime.Now)
		Console.WriteLine("migrating date {0}", DateTime.Now);


			}

//class that actually implements interface iscalled as concrete class

and the other class which uses instance of Interface, we ssay its dependency injection is happening
===================================

public interface ILogger{

	void LogError(string message);
	void LogInfo(string message);

}


====================================

static void Main(){
	
	var console_logger = new ConsoleLogger ();

	var dbmigrator = new DBMigrator(console_logger);

	dbMigrator.Migrate();

/// lets say if we want to log essages into file
// then create a new class

public class FIleLogger : ILogger{
	private readonly string _path

	public FIleLogger(string path){
		_path =path;
	}

	public void LogError(string message){
		
		using(var streamWriter = new StreamWriter(_path, true))
		  //true is for append
		{
		streamWriter.WriteLine("ERROR: " +message);
	}
		//problem file resource is not managed by CLR, common language runtime, and hence we should use using
	}

	public void LogError(){
	}
	public void LogInfo(){
		}


}

//var dbMigrator = new DBMigrator("C:\\projects\\log.txt")


}
		
\\\\\total review

	==>one main program
	==>one class to inject dependeny
	==>one interface
	===>and many concrete class



__________________________________________________________________________________________________________________________________________________________

S6E4

interface is not for multiple inheritance

can have multiple interfaces

	==>only for loosely coupled

__________________________________________________________________________________________________________________________________________________________

S6E5

Interface and polymorphism

open closed principles ====>	open for extension, and closed for modification

public class CLaawhichwillHaveDependencyInjection{

private readonly ILisy<IInterface_name> _instanceName;

public constructor(){
 
 _instanceName = new List<IInterface_name>();

}

public void ToAccessAllList(CLass instance){
	foreach(var channel in _instanceName)
		channel.method_name(new CLass());


}
}


//events and delegates is another solution to handle theses problems


---------------------------------------------------------------------
extra https://www.youtube.com/watch?v=jQgwEsJISy0

using System.Threading;



Thread.SLeep(3000);


---------------------------------------------------------------------

__________________________________________________________________________________________________________________________________________________________

S7E1

final words

__________________________________________________________________________________________________________________________________________________________

S7E2

other courses

	==>double your coding speed

	==>C# advanced course

__________________________________________________________________________________________________________________________________________________________

S8E1

stop watcher exercise

	==>make properties as private
	==>dont use get and set, if we dont need them

	//DateTime.Now;
	//DateTime.Today.AddDays(1);
	//Thread.Sleep(1000)  //1s

__________________________________________________________________________________________________________________________________________________________

S8E2

using System.Collection.Generic;

private List<object> _list = new List<objec>();

_list.Add(obj);
_list.Remove(obj);
_list.Clear()

_list.RemoveAt(_list.Count -1);

		
		//_ is for private fields in class

__________________________________________________________________________________________________________________________________________________________

S8E3

IEnumarable<IInterface>  ==>read only version of list
			//usinf System.Collection.Generic


		....done

__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________


[FreeTutorials.Us] [UDEMY] C Sharp Advanced Topics Prepare for Technical Interviews [FTU]


__________________________________________________________________________________________________________________________________________________________
S1E1


About this course

__________________________________________________________________________________________________________________________________________________________
S1E2

	instructor is Mosh Hamedani


__________________________________________________________________________________________________________________________________________________________
S1E3

how this course is organised?


__________________________________________________________________________________________________________________________________________________________
S2E2

Generics

public class ListOfObjects{

public void Add(object value){

	
	//in case of object we have box and unbox or type cast or uncast
	}
}

public class GenericList<T>{
	public void Add(T value){
	
	}

	public T this[int index]{
		
	}
}

public class GenericDictionary<Tkey, Tvalue>{
	public void Add(Tkey key, TValue value){
	
	}
}

Main(....){

var numbers = new GenericList<int>();
numbers.Add(10);

var books = new GenericList<Book>();
books.Add(new Books());

var  dictionary = new genericDIctionary<string, Book>();
dictionary.Add("1234", new Book());


//Syste,Collection.Generic.
//above you will get all the generics

}

==============================================

public class utilities{

public int max(int a, int b){
	return a<b ? a : b;

	public T Max<T>(T a, T b) where T : IComparable
	{ 
		// as it does not know where it is comparable 
		return a.CompareTo(b) > 0 ? a : b;
	}
}

//it can be "where " declared to class level as well

//where T : IComparable
//where T :product
//where T :struct
//where T :class
//where T :new()


}

============

public class Nullable<T> where T : struct{

public Nullable (T value)
{
	_value = value;
}

public bool HasValue{

get {return _value!= null; }}
}

public T GetValueorDefault(){
if (HasValue)
	return (T)_value;

	return default(T); // will give default value of that generic that come

}

========================================================

public class GenericDictionary<TKey, TValue>{
	public void Add(Tkey key, TValue value){
	
		
	}
}

=============

Main(....){

	var dictionary = new GenericDictionary<string, Book>();
	dictionary.Add("1234", new Book());


}
===============================================================


when we want to limit the constraint


public class Utilities<T> where T : IComparable{
	
	public int Max(int a, int b){
		return a>b ? a: b;
	}

	public T Max(T a, T b) {
		return a.COmpareTo(b) > 0 ? a: b; // in this case we dont know which is comparable
	}
}
=================================================================

public class DiscountCalculator<TProduct> where TProduct : Product{
	public float CalculateDiscount(TProduct product)
{
	return product.price;
}
}

=================================================================

	public class Nullable <T> where T : struct{
	
		private object _value;

		public Nullable(T value){
			_value = value;
		}

		public bool HasValue{
			get { return _value != null; }
		}

		public T GetValueOrDefault(){
			if(HasValue)
				return (T)_value;
			return default(T);
		}
	}


=================================



Main(....){
	var nmber = new Nullable<int>(5);
	Cnsole.WriteLine("has value ?" + number.HasValue);
	Console.WriteLine("Value" + number.GetValueOrDefault()); 
}

===============================================================

// can add more than one constraint using ,


__________________________________________________________________________________________________________________________________________________________
S2E3

Delegate

	==>calling a function by its address

	class PhotoProcessor{
	
	public delegate void PhotoFilterHandler(Photo photo);
	
	public void Process(string str1, fn_name reference_name){
	
		var photo = Photo.load(path);

		var filters = new Photofilters();

		
		//filters.ApplyBrightness(photo);
		//filters.applyContrast(photo);
		//filters.Resize(photo);

//instead
		filterHandler(photo);

		photo.save();
	}
	}


=======================================================

main(.......){
	var processor = new PhotoProcessor();
	var filters = new PhotoFilters();
	PhotoProcessor.PhotoFilterHandle filterHandler = filters.ApplyBrightness;

	filter+=filter.ApplyContrast;

	processor.Process("photo.jpg", filterHandler);
}


//what we are doing here is , we have all the function in one class but not anymore which  have delegates, and  we are choosing which all functions to call at main

//we are adding function having same structure, and all are independent I suppose



__________________________________________________________________________________________________________________________________________________________
S2E4

Lambda expressions
	
	==>method having no name

	==>no modifer

	==>used for convinent

	
//args lambda operator and expression

number => number*number //it needs to be assigned to delegate

//if we dont want parameters



Func<int, int> square = number => number*number  //first represent arguemnet, 2nd one is return typr

Console.WriteLine(square(5));

	//func<>
	//Actions<> ==>does not return value


==================================================
cons int factor = 5;

Func<int, int> multiplier = n => n*factor;

var res = multiplier(10);

Console.WriteLine(res);

==================================================


new List<Book>{
	
	new Book(){Title ="dfd", price=50},
	new Book(){Title ="this", price=501},
	new Book(){Title ="is", price=502}

}

//this is what we call object initialiser


var getFilteredBooks = books.FindAll(// this takes functions which returns boolean)

OR

//books.FIndALl(book => book.price < 10);



foreach (var book in getFilteredBooks){
Console.WriteLine(book.title);
}
//predicate ==>a deligate or small small functions


__________________________________________________________________________________________________________________________________________________________
S2E5

Events and delegates in C#
		
	events ==> mechanism for communication b/w objects

		==>helps in loosely coupling

		==>when one class is dependent to another, then recompile is needed

		like encoind method has sending mail line

in subscriber

public void VideoEncoded(object source , EventArgs e)


////Thread.sleep(3000) //3seconds

//1- DEfine a delegate
//2- define an event based on that delegate
//3- raise an event

public delegate void VideoEncodedEventHandler(object source, EventArgs args); /// EventArgs  an additional data, if we want to send some data, then that class must be inherited from EventArgs

	//apppend EventHandler 

public event VideoEncodedEventHandler VideoEncoded;

pubic void Encode(Video video){
OnVideoEncoded();
}

protected virtual void OnVideoEncoded(){
	//event publisher method should be protected and virtual
	if(VideoEncoded != null)
		VideoEncoded(this, EvenntArgs.Empty); //this is the source
}


////////==============================================

//now in subscribers

//signature should be same as delegates

class Program{
	
	var videoENcoder = ner VIdeo Encoder();

	videoEncoder.VideoEncoded += mailService.OnVideoEncoded;  //mailService.OnVideoEncoded this is a refernce of function . not we are calling function
		// video encoder is publisher, we are interested in VideoEncoded event
	videoEncoder.Encode(video);
}

public class MailServeice{
	
	public void OnVideoEncoded(object source, EventArgs e){
		
		COnsole.WriteLine("Mailservicw: sending an email");
	}

}


// resharper plugin==>alt+enter==>will move class to new file

__________________________________________________________________________________________________________________________________________________________
S2E6

//Extension methods

class Program {

static void main(string[] args){
	string post = "This is supposed to be a very long";
	var shortenedPost =  post.Shorten(5);

	
	}

	public static class StringExtension{
		public static string Shorten(this String str, int numerOfWords){
			if(numv=berOfWords < 0)
				throw new ArguementOutOfRangeException("number should be positive integer");
			if(numberOfWords == 0)
				return "";
			var words = str.Split(' ');

			if(words.Length <= numberOfWOrds)
				retrn str;
			
			return string.Join(" ",words.Take(numberOfWords));
		}
	}
}

//extension method has scope of namespace

//use extension method only you have to

__________________________________________________________________________________________________________________________________________________________
S2E7




















	....icomp
