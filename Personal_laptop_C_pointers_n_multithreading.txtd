[Tutsgalaxy.com] - Mastering Advanced C Programming Pointers (In Depth)

__________________________________________________________________________________________________________________________________________________________

S1E1

By Ravi kishore

	==>data variables and pointer variables

		==>pinter variable==>holds address of same type of data

		==>size of pointer will be same as architecture of processor


__________________________________________________________________________________________________________________________________________________________

S1E2

int a

		//garbage value is like junk value

int *p  ==>* is for defining a pointer variable

p = &a

__________________________________________________________________________________________________________________________________________________________

S2E1

	doc

__________________________________________________________________________________________________________________________________________________________

S3E1

	single pointer
===============================
	#include<stdio.h>

	int main(){
		int a = 10;
		int *p;
		p =&a;
		printf("a = %d, p=%x, &a=%x, *p = %d\n", a, p, &a, *p)
		return 0;
	}

	================

	gcc file_name.c

	>>./a.out


__________________________________________________________________________________________________________________________________________________________

S3E2

c supports 12 level of pointer ==>like nesting pointer

int **q ==>two level pointer, it is defining

*(***r)  ===>it is two access like this


__________________________________________________________________________________________________________________________________________________________

S3E4.5

practical

__________________________________________________________________________________________________________________________________________________________

S4E1

Lvalue and RValue 

	lValue at compile time==>represents address

	rValue at runtime==>represents value


__________________________________________________________________________________________________________________________________________________________

S5E1.7

	type needs to be matched, as we can inrement pointers too



__________________________________________________________________________________________________________________________________________________________

S6E1.8


Arithmetic operations in pointers

	+,-,*,/

	==>performed in same type of pointers

	segmentation faults ===>when resultant address is not there in memory(after performing arithmetic operations)

	p1 * p2 and p1/p2  ==>is not poosible
	
	==>p + 1*(size of ptr)

	
__________________________________________________________________________________________________________________________________________________________

S7E1.9

	pre and post increment of pointers

	int a[3] = {10,20,30};

	int *p =a;

	res = *p++;  //increment to pointer and we will get incremented address

		=*++p // in this we will get value of incremented pointer

		=++*p //we will get incremeted value

__________________________________________________________________________________________________________________________________________________________

S7E2.10

	int main(){
	
	int a[3]={10,20,30};
	int *p;
	int res = -1;
	p =a;

	res = *p++; //result is incremented pointer
	res =*++p; //result is 20
	res = ++*p; //res eill be 11

	}
		
__________________________________________________________________________________________________________________________________________________________

S8E1.11

generic pointers

	==>earlier we had same pointers

		==>no mis match allowed earlier

	==>generic pointer is compatible with any type of data

	==>it is represented with void*

	==>it only knows how many bytes of address is using

==================================
	int arr[5]={10,20,30,40,50};

	void *p;

	p=arr; // here it does not know what type of data it is holding, but it knows that it have 20 bytes as size of array


	printf("%d",*p) //error

			==>now we need to type cast 

	printf("%d",*(int*)p) ==>//we type casted and then retrieving

	===================

	dereferencing ==>is getting the value from pointer

	==>no data loss using generic pointer, no extra memory needed

	==========================================
	int main()
	{
		int a = 10;
		float f = 4.8;

		void *p;

		p =&a;
		printf("a =%d ",*p); //wwe will get error
		printf("a =%d ",*(int *)p); // now we will get the value
		printf("a = %d\n",*(char *)p); //it will print 0, as its knowing that it holds one character
			//if int a =257 // then it will give 1, if we try to get value from char pointer type

		return 0;
	}


__________________________________________________________________________________________________________________________________________________________

S9E1.12

null pointer

	===>PAS ==>process address space is given by OS, every time program starts

	==>segments that process have

		==>code segment
			===>text section
			==>instruction

		===>Data segment
			==>.data section (initialised memory for static and global variables)
			==>.bss section (uninitialised, default initialised to 0)

		==>Stack segment
			==>Stack section(used for program execution & memory for local variables)
			==>Heap section (runtime memory allocation)

			
==>when program crosses PAS, we get segmentation fault

__________________________________________________________________________________________________________________________________________________________

S10E1.13

	significance of initialisation of pointer to null

		==>if it is not initialised with null we will get some different value
			or we will get segmentation fault

		int *p = (int *)0;

		or

		int *p = (void *)0;

		#define (void*)0 NULL

			==>now  we will ger NULL pointer dereferenced

__________________________________________________________________________________________________________________________________________________________

S10E2.14

	vi nullpointer.c

	#include<stdio.h>

	int main(){
	
		int a; //garbage value
		int *p; //garbage value

		printf("a= %d, p=%u",a,p);
		

		return 0;
	}



__________________________________________________________________________________________________________________________________________________________

S11E1.15

contant pointers

 const char *p; ==> pointer can be updated, data can not

 char const *p; ==>pointer can be updated, data can not

 char * const p; ==> data can be updated, pointer can not

 const char * const p; ==> pointer can not be updated,also data can not


## think it like char word is not there

__________________________________________________________________________________________________________________________________________________________

S11E2.16

main(){

char arr[4] = {'A', 'B', 'C'};
const char *p = NULL;
return 0;

char * const p; //ptr is constant but *ptr is not constant


}

////>>> gcc filename.c
>>>./a.out

__________________________________________________________________________________________________________________________________________________________

S12E1.17

Allocate memory dynamically

	//stack memeory is for static memory
			
			==>local variables
			==>Heap Section

	//heap section is for dynamic memory
			


__________________________________________________________________________________________________________________________________________________________

S12E2.18

whenever main function gets called

	==>stack segment comes into picture

		==>stack section
			==>it has more memory in whole stack segment

		==>heap section
			==>we will get the base address of heap , and will store in stack section

			==>we have to free all the written data in heap, and it will not be used as OS will think it is attached to some process

			==>So we have to free in heap, as only stack gets released by OS after completeion of pgm


__________________________________________________________________________________________________________________________________________________________

S12E4.19


function to allocate dynamic memory 

	void* malloc(size_t size);

		==>will allocate in sequence

		==>on success, will give return address (generic address , needs to be type casted)
		
		==>on failure , return NULL



__________________________________________________________________________________________________________________________________________________________

S12E5.20

#include<stdlib.h> //else you will get warning

	in malloc ==>new created memory will not be initialised

	main(){
	
	char *p = NULL;
	//hello
	p = (char *) malloc(6*sizeof(char));
	//above stmt will create 6 block of m/m in heap

	if (p==NULL){
		printf("memory allocation using malloc failed\n");
		return -1;
	}else{
		printf("m/m allocation success\n");
	}
	
	char *p1=p;

	*p ='h';
	++p;
	*p ='e';
	++p;
	*p ='l';
	++p;
	*p ='l';
	++p;
	*p ='o';
	++p;
	*p='\0';

	printf("data stored in dynamic memory is %s\n", p1); // we will get all characters

	free(p1); //now it will maintain all the m/m from base address
	//*p1; // now we have released it from our program

	return 0;
	}

//valgrind ==>is tool to find memory leaks

>>>valgrind --tool=memcheck --leak-check=yes ./a.exe


__________________________________________________________________________________________________________________________________________________________

S12E7.21

calloc (sixe_tnum_elements,size_telement_size)
	
	//in this case we dont have multiply how many char we need
	// as it asks while calling
	//also it initialises , every byte with 0 in case of int, and '\0' in case of char
 
	// it also returns void * ===>generic pointer , hence we need to type cast
===========================================
	//hello
	char *p;
	p = (char *) calloc (6, sizeof(char));
	
	// if p is NULL , m/m allocation failed



__________________________________________________________________________________________________________________________________________________________

S12E9.22


*realloc(void *ptr, size_t_new_size)
	
	// first parametr is base address from where we need to make change
	==>extend or reduce the existing memory in heap

	//like we have 5 blocks earlier
	
	realloc(base_addr, 10*sizeofc(char))

		//==>it will return void*, then we need to type cast

		// if it is possible
		//if not possible, then it tries to get some other location, and copy old m/m to new blocks
			//and in this case, it will be freed by realloc automatically, and it will return new address
		
		===================

		now if not able to extend anywhere our request,
			//in case of failure it will return NULL, otherwise we would have gotten some address
			// and also we will lose the refernce, and there is memory leak
				// in that case experiment with othercase in case of realloc

//problem of above solution and in case we are not able to proceed
		if(p1==NULL){
			free(p);
			return -1;
		}
			

===>realloc also used reduce the allocated m/m

earlier 

ptr = (int *) malloc (2*sizeof(int)); //i.e we have asked for 8 bytes

now

ptr = (int *)realloc(ptr,4);

//if base address is null, then it is equivalent to malloc

if size is 0 ==>then it is like free(ptr)


__________________________________________________________________________________________________________________________________________________________

S12E10.23

#include<string.h>

if (p ==NULL){
printf("failure state")
}

strcpy(p, "hello");

//requirement for increase to 10 bytes

	char *p1 =NULL;
	p1=(char *)realloc(p,10*sizeof(char));
	
	if(p1==NULL){
		printf("realloc failder")
		free(p);
		return -1;
	}else{
		printf("realloc is successfully allocated new memory\n");
		p=p1;

	}

strcpy(p,"helloravi");

printf("p=%p",p);


__________________________________________________________________________________________________________________________________________________________

S13E1.24

Memory leak
	==>memory is existing but pointer is not there
	


Dangling refernce
	==>memory is not there but refernce is still there, even after free the memory with some other refernce
	==>we should avoid of copying the pointers
			==>instead we could copy the same data in some other ptr at some other location

what have we discusser

	===>pointers
	==>level of pointers
	==>lvalue and rvalue
	==>arithmetic operations with pointers
	==>generic pointers and casting of pointers
	==>NULL pointer
	==>pointers with constant
	==>Dynamic memory allocation
		==>malloc
		==>calloc
		==>realloc
	==>free(address)


		...done


__________________________________________________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________________________________________________

[TutsNode.com] - Master Class - Multithreading & Thread Synchronization in C

__________________________________________________________________________________________________________________________________________________________

S1E1

	what are threads?

		==>basic unit of execution
		==>every program must have atleast one thread
		==>we call it main thread
			==>the main one
		==>process is main thread
		==>process needs to be created before thread
		==>thread can create more thread
			==>at any point
		==>parent child and child thread
		==>we can see branching like structure when we see thread
		==>fork point
			==>point where a new thread is created


__________________________________________________________________________________________________________________________________________________________

S1E2

	Code Acess

		==>path of hello_world multi threading program

__________________________________________________________________________________________________________________________________________________________

S1E3nE4

	basic multithreading program

	#include<pthread.h>
	#include<unistd.h>

	void thread1_creae(){
	
	//every thread is idefied by data structure
	//opaques to developer, datastructure member to developer
	pthread_t pthread1; //it is called thread handler

	static char *thread_inpur1 = "I am thread no 1";
	

	int rc = pthread_create(&pthread1,NULL,thread_fn_callback,(void *)thread_input1) //API provided by POSIX threads library (pthread.h), address of thread_handle, 2nd arguement will discuss later, thread_fn_callback, (void *)thread_input1 =>it is memory provided as input to this thread
						// this memory must be on heap(dynamic memory allocated) or can be static, must not local memory to this function
						// locla memory is in stack which can not be passed
						//the above line is fork point as it is giving birth to child thread
	if(rc != 0 )  //rc == 0 is success
	{
	printf("Error occured, thread could not be created, err no =%d\n", rc);
	exit(0);
	}			//negative value represents error

	}
	


	//main thread will create more thread

	int main(){
	thread1_create();
	//main thread terminate then all child threat will terminate
	

	pause(); //#include<unistd.h>
	return 0;
	}

		// we can not pass local variable , as once the function is over , all local memory is gone


--------------------------------

__________________________________________________________________________________________________________________________________________________________

S1E4
	//thread_fn_callback ==>fn which new thread will execute
	
	prototype
	
	static void* thread_f_callback(void *args){
		char *input = (char *)args;

		while(1){
			printf("input string = %s\n",input);
			sleep(1);
		}
	}

//compile using
>>gcc -g -c hello_worls.c -o helo_world.o
>>>gcc -g hello_world.o -o hello_world.exe -lpthread   //with your exe , link with pthread library
>> ./hello_world.exe

//child thread can not control parent child normally, we have to pause main, otherwise child thread will terminate before its birth

//read Race condition



===============================================================



#include<stdlib.h>
#include<pthread.h>
#include<unistd.h>
#include<stdio.h>
static void * new_thread(void  *msp){
        char *mess_from_par = (char*)msp;
while(1){
printf("message from parent %s\n",mess_from_par);
sleep(1);
}
}

int main(){
printf("this is main thread\n");
static char *msg_to_child="this is message from parent";
pthread_t pthread1;
int rc =pthread_create(&pthread1,NULL,new_thread,(void*)msg_to_child);
printf("rc = %d",rc);
pause();
return 0;
}



gcc -g -c basiC_thread.c -o basiC_thread.o

gcc -g basiC_thread.o -o basiC_thread.exe -lpthread

./basiC_thread.exe



// if ifinite loop will not be there in that child thread you wont be able to see the output


============================================================================
__________________________________________________________________________________________________________________________________________________________

S1E5

	Race condition

// last arg to thread_create is data input to thread, which is dynamic

//we can not say the sequece of execution after fork point

// still 99.9 % is chance that our already running thread will get chance

//this refers to race condition on thread creation

__________________________________________________________________________________________________________________________________________________________

S1E6

	thread termination

	// when a new thread created , how can it be terminated

		==>when thread fn returns
		==>pthread_exit(0);
		==>Thread cancellation // by another thread
	

cont---------------

int a=0;
while(a<10){
printf("input string %d",input);
sleep(1);

//or

if(a==5){

pthread_exit(0);

}
//
a++;


}
====================

//cancellation by another thread

T1 will send cancel request to T2 or vice versa ==>and immediate effect can be seen

__________________________________________________________________________________________________________________________________________________________

S1E7

main thread tremination

	parent thread wont be terminated because of child termination

	// main thread can also be exit by

	pthread_exit(0); // in main function, but in this  case child will still be executing

	return 0; //irt will terminate all child thread

/////////////

what if child thread terminates, no impact on others

__________________________________________________________________________________________________________________________________________________________

S1E8

Resource Sharing
	
	what are the resources that all threads share

	==>OS share resource to threads

		==>any thread can ask for memory
		==>scheduling poicy will be decided by OS
		==>All threads are siblins

			==>all are siblings 
			==>they all will have their own life cycle
			==>when main threa dies, then all will be terminated
					==>vice versa is not true
			==>parent only means that it crates new child thread==>other than that thre's no difference
			==>share same virtual process Address space
					==>they all have common access to heap
					==>heap memory, sockets, file descriptor, global variables
			==>every thread has its exclusive stack memory
				==>in case of stack memory, it is very private to each thread



__________________________________________________________________________________________________________________________________________________________

S1E9

	==>after thread creation 
		==>no separate virtual memory for new thread
		==>share same VAS (virtual address space)
		==>whereas all thread have their own stack memory

__________________________________________________________________________________________________________________________________________________________

S1E10

	Thread Scheduling

		==>kerner do not schedules process, it schedules threads

		==>thread is a schdulable entity, not a process

		==>suppose P1 has two threads t1 and t2, and p2 has two threads t3 and t4

		==>kernel will give threads to cpu to get executed

			==>if threads gives segmentation fault, then entire process is terminated

					==>in that case , other thread of that process also had to suffer and not will be executed
			
			==>a signal is delivered per process, not per thread
					==>like segment fault signal
			
			==>race thread is like kernel chooses which thread for CPU


__________________________________________________________________________________________________________________________________________________________

S2E1 (Concurrency V/s Parallelism)


	==>Context switching
		==>Concurrency
			==>doing two or more task
			==>one at a time
			==>switching task
			==>picking it, preempt current task
			==>picking up next , partially do it and preempt it
			...and so on

			e.g real world ==>well digger ==>one drill machine

				==>only can dig at a time
				==>when one take rest, 2nd person starts from there
				==>and so on
				==>and they do untill it finishes
		
	
		==>Parallelism

__________________________________________________________________________________________________________________________________________________________

S2E2

	Parallelism

		==>e.g
			from above example they all can drill, as they all are having their own drilling tool
		
		time is reduced to = T/3 from previous exmaple

		time taken in paralllelism << time taken in concurrency

__________________________________________________________________________________________________________________________________________________________

S2E3

	Singularism

		==>one task at a time
		==>Dont preempt until the task is complete
		==>next start his job until previous one completes

	==>e.g. ==>work of all the well-driggers is NOT in progression

	time taken in parallelism << time taken in singularism < time taken in concurrency

		// as handover of tool is not there in singularism
		//concurrency gives progression

__________________________________________________________________________________________________________________________________________________________

S2E4

workers ==> well diggers ==>thread

resources ==>Digging tool ==>CPU & memory etc

Transition ==> One well digger to another ==>context switching

work to accomplish ==>100 ft well ==>work to be done by each thread

__________________________________________________________________________________________________________________________________________________________

S2E5

	COncurrent thread execution

	T1		n T2		n T3
	[1 to 6]        [1 to 6]       [1 to 6]


	==>Ready queue ==>if concurrent , after some time they all start to wait

		==>they all show property of progression

==>Parallel threads

	==>non of thread infringes to another
	==>they all are independent
	==>now we have to have more resources
	==>expensive one

==>Singular threads
	
	==>no progression
	==>doesn't exist in real world of threads


__________________________________________________________________________________________________________________________________________________________

S2E6

why do we need concurrency ??

	ctrl+shift+esc

		==>go in performance

		==>you can see no. of nores

			and logical processor

		==>hybrid (concurrency and parallelism) is best option for current typical computers


__________________________________________________________________________________________________________________________________________________________

S2E7

	==>We need concurrrency because , we can not have many CPU
	==>we also need to ensure progression

	==>like in case waiting for network packets, waiting for i/p n o/p event from user etc

__________________________________________________________________________________________________________________________________________________________

S2E8

	concurrency example 2

		==>when work can be splitted into smaller independent chunks which can be processed by worker threads

		==>TCP server delegates the task to worker threads to entertain the client request

		
__________________________________________________________________________________________________________________________________________________________

S2E9

	why threads are called light weighted process?

		==>as it uses almost all pre-existing resources of already created thread

		==>also OS doesnt have to take that effort to create isolated environment

				==>page tables are already setup
				==>shared libraries are already loaded
				==>sockets are already opened
		
		==>when thread dies, OS doen't have clean as it might be already created threads

		==>thread switching is faster than process switching

__________________________________________________________________________________________________________________________________________________________

S2E10

Overlapping and non overlapping work

	==>w1(work1) and w2 ==>are overlapped when they operate on same data
	
	==>if threads shares the data, say some global data then threads have overlapping work

__________________________________________________________________________________________________________________________________________________________

S2E11

Summarize this section
	
	==>when thread cpu shares the same CPU, it is concurrency
		regardless of data sharing, overlapping or non overlapping

__________________________________________________________________________________________________________________________________________________________

S3E1

	Joinable and detachable Threads

	threads can be created in two different modes

		==>joinable threads

			//pthread_create can have arguement for that

			T1 and T2

			T1 calls pthread_join() ==>parent thread gets blocked until child thread complete its execution and join
						==>parent thread will resume when it will get join signal from parent
						==>once child joins with parent , then parent can continue its execution

						===>resource of joijnable thread are not released until it joins the parent thread
						==>a joinable can be converted to detachable while its running or vice versa
						==>by default, thread runs on joinable mode
						==>joinable thread may return the result to join thread

			

		==>detachanle threads

__________________________________________________________________________________________________________________________________________________________

S3E2

	==>in detachable thread 
	==>theres no need to join with parent thread
	==>kernel will automatically released once its complete its execution
	==>can be converted in between of execution and vice versa

__________________________________________________________________________________________________________________________________________________________

S3E3

	// joinable thread in action

#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<unistd.h>
#include<errno.h>



pthread_t pthread2;
pthread_t pthread3;

static void * thread_fn_callback(void *args){
int th_id =*(int *)arg;
free(arg);
int rc = 0;
while(rc != th_id){
	printf("thread %d doing some work \n ", th_id);
	sleep(1);
	rc++;


}

int *result = calloc(1,sizeof(int));
*result = th_id *th_id;
return (void *)result;
	//result is also need to be shared as dynamic menmory
}

void thread_create(pthread_t *pthread_handle, int th_id){
	pthread_attr_t attr;

	int *_th_id = calloc(1, sizeof(int));
	
	pthreada_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);  // PTHREAD_CREATE_DETACHED
		
		//we need to get the access to the attribute which we are setting joinable or detached   

	

	pthread_create(pthread_handle,    //this line is fork point 
			&attr,
			thread_fn_callback,
			(void *) _th_id)
}



int main(int args, char **argv){
	
	void *thread_result2;
	thread_create(&pthread2, 2);
	thread_create(&pthread3, 10);
	
	//wait to join
	
	printf("man fn blocked on pthread join for thread with th_id = 2\n");
	pthread_join(pthread2, &thread_result2);  //pthread-join is block api
	
	if (thread_result2){
	printf("returned result from thread 2 = %d\n", *(int *)thread_result2);

	free(thread_result2);
	 // reponsible of parent to release memoru used by child to get result

	 thread_result2 =NULL;

	}


	pthreaad_join(pthread3, &thread_result3);

	if (thread_result3){
	printf("returned result from thread 2 = %d\n", *(int *)thread_result3);

	free(thread_result3);
	 // reponsible of parent to release memoru used by child to get result

	 thread_result3 =NULL;

	}

	return 0;
}


__________________________________________________________________________________________________________________________________________________________

S3E4

	can it join any thread?

		==>yes, any thread is blocked for joining, it can join anywhere

		==>any joining point with same thread handle , can join

		==>and can join both or any number which thread_handler

		==>only joinable thread gets joined


__________________________________________________________________________________________________________________________________________________________

S3E5

Exercise

	Implement Map-Reduce
	
	==>count no of words in file of 1200 lines

	==>distribute work and combine


__________________________________________________________________________________________________________________________________________________________

S3E6


	how to choose joinable or detachable
	
	joinable
		==>if thread is supposed to return some value ==>go for joinable thread
		==>if we want to notify, then go for joinable

	detachable
		==>waiting for user input
		==>waiting for networks pkt
		==>infinite loop



__________________________________________________________________________________________________________________________________________________________

S4E1

	Inter thread communication

		==>exchange of data b/w threads within a process

		==>various IPC techniques

			==>Sockets
			==>Msg Queues
			==>Pipes
			==>Shared Memory

		==>communication between thread is preferred
			==>very fast
			==>No actual tranfer of data but 
			==>transfer of computation
			==>No special attention required from kernel, Completely run in user space
			==>No kernel resource need to be explicitly created


__________________________________________________________________________________________________________________________________________________________

S4E2

	Transfer of computation

		==>transfer of logic is feasivible when both entity are in same VAS(virtual address space)

__________________________________________________________________________________________________________________________________________________________

S4E3

	Entity 1 wants to use function of Entity 2

		==>Transfer of registration is reponsibility of Entity 2

		==>fn is used by entity 1, but result is there with Entity 2
		
__________________________________________________________________________________________________________________________________________________________

S4E4

publisher subscriber model

	==>also known as notification chain

	==>thread which generates data is called publisher

	==>thread which owns the data processing function is called a subscriber

	==>the activity of TOC is called Callback Registration

	==>the activity od invoking the fn through fn pointers by publisher is called Notification

__________________________________________________________________________________________________________________________________________________________

S5E1

	Vacations

		==>Doubly linked list = Glue based linked list

__________________________________________________________________________________________________________________________________________________________

S6E1

	==>Notification chains

		==>architecture concept

		==>to notify all subscriber


		==>subscribers are notified

		==>==>subscriber can register or derigister for the event their at will

		==>event is generated by publisher, and pushed to subcribers


		==>can be anywhere

			==>within process
			==>within different or same system

__________________________________________________________________________________________________________________________________________________________

S6E2

 Notification chain(NFC)

	==>publisher is incharge of routing table

	like newspaper subscription and publisher

	==>if subscriber wont tell about the specific newspaper subscription , then publisher will give all the events and magzines information

	==>NFC is the detail where publichers keep the information about subscribers
__________________________________________________________________________________________________________________________________________________________

S6E3

	NFC is a linked list of callbacks (function pointers)

	typedef struct notif_chain_ {
		char nfc_name[64];
		glthread_t notif_chain_head; //this is head of linked list
	} notif_chain_t;

	typedef struct notif_chain_elem_{
		char key[MAX_NOTIF_KEY_SIZE];
		size_t key_size;
		bool_t is_key_set;
		nfc_app_cb app_cb;   //typedef void (*nfc_app_cb)(void *,size_t);
		glthread_t glue;
		
	} notif_chain_elem_t;


==========================================================================

notif.h

#define MAX_NOTIFY_KEY_SIZE 64

typedef void (*nfc_app_cb) (void *, size_t);

typedef struct notif_chain_elem_{
	
	char key[MAX_NOTIF_KEY_SIZE];
	size_t key_size;
	bool_t is_key_set;
	nfc_app_cb app_cb;
	glthread_t glue;
	
} notif_chain_elem_t;

GLTHREAD_TO_STRUCT(glthread_glue_to_notif_chain_elem, notif_chain_elem_t, glue);

typedef struct notif_chain_ {
	
	char nfc_name[64];
	glthread_t notif_chain_head;
} notif_chain_t;


__________________________________________________________________________________________________________________________________________________________

S6E4


	subscription request ==> need to invoke by the subscriber
	
		void nfc_register_notif_chain(notif_chain_t *nfc, notif_chain_elem_t *nfce);
		


	Invoke request

		void nfc_invoke_notif_chain( notif_chain_t *nfc,
					void *arg,
					size_t args_size,
					char *key,
					size_t key_size);

	
==============================================================

notif.c

void nfc_register_notif_chain(notif_chain_t *nfc, notif_chain_elem_t *node){

	notif_chain_elem_t *new_nfce = calloc(1, sizeof(notif_chain_elem_t));
	memcpy(new_nfce, nfce, sizeof(notif_chain_elem_t));
	init_glthread(&new_nfce->glue);
	glthread_add_next(&nfc->notif_chain_heaad, &neew_nfce->glue);

}

void nfc_invoke_notif_chain(notif_chain_t *nfc,
			void *args, size_t arg_size,
			char *key, size_t key_size){
			

		glthread_t *curr;
		notif_chain_elem_t *nfce;
		
		assert(key_size <= MAX_NOTIF_KEY_SIZE);

		ITERATE_GLTHREAD_BEGIN(&nfc->notif_chain_head, curr){
			
			nfce = glthread_glue_to_notif_chain_elem(curr);

			if(!(key && key_size && nfce->is_key_set && (key_size == nfce->key_size))){
			
				nfce->app_cb(arg, arg_size);
			}
			else{
				if(memcmp(key, nfce->key, key_size)== 0){
				nfce->app_cb(arg, arg_size);
				}
			}
		}ITERATE_GLTHREAD_END(&nfc->notif_chain_head,curr);

			}



// we can also unsubscribe


__________________________________________________________________________________________________________________________________________________________

S6E6

publisher and subscriber model

	==>1 publisher and 3 are subscriber thread

	
__________________________________________________________________________________________________________________________________________________________

S6E7

//at publisher end

typedef struct rt_entry_keys {
	char dest[16];
	char mask;

} rt_entry_keys_t;

typedef struct rt_entry_{

	rt_entry_keys_t rt_entry_keys;
	char gw_ip[16];
	char oif[32]; //output interface, any external data
	struct rt_entry_ *prev;
	struct rt_entry_ *next;
} rt_entry_t;


typedef struct rt_table_{   //it caries header pointer

	rt_entry_t *head;

} rt_table_t;

	
==================================================

// implementation of apis

void rt_init_rt_table(rt_table_t *rt_table);

rt_entry_t * rt_add_or_update_rt_entry(.......)

bool rt_delete_rt_entry(......);

rt_entry_t* rt_look_up_rt_entry(.....)

void rt_dump_rt_table(...)

__________________________________________________________________________________________________________________________________________________________

S6E8

#include "rt.h "


int main(int argc, char **argv){

	rt_init_rt_table(&publisher_rt_table);

	/*Create Subscriber threads */



}


//rtm_publisher.c

rt_table_t publisher_rt_table;

rt_table_t *
publisher_gwt_rt_table() {

return &publisher_rt_table;

}

void main_menu() {
	int choice;
	while(1){
		printf("Publisher menu \n");
		printf("Add/update rt table entry \n");
		printf("2. Delete rt table entry \n");
		printf("3. Dump rt table\n");
		printf("Enter choice \n");
		choice=0;
		scanf("%d", &choice);
		switch(choice){
			case 1:{
				char dest[16];
				char mask;
				char oif[32];
				char gw[16];
				printf("Enter Destination : ");
				scanf("%s", dest);
				...get mask
				...get oif name
				..get GatewayIP

				rt_add_or_update_rt_entry(...);
				
			}
			case 2:{
			//delete rt table entry
			break;
			}

			case 3:
			rt_dump_rt_table(publisher_get_rt_table());
			break;

			default: ;
		}
	}
}



int main(){

	rt_init_rt_table(&publisher_rt_table);

	create_subscriber_thread(1);
	sleep(1);

	
	create_subscriber_thread(2);
	sleep(1);

	
	create_subscriber_thread(3);
	sleep(1);

	pthread_exit(0);
	return 0;
}

	...incomp
__________________________________________________________________________________________________________________________________________________________

S6E9

threaded_subscriber.c

// create_sucbcriber thread ==>invoked by main fn
	
	//we need to make subscriber
//create subscriber_thread_fn

//static void test_cb() //test call back

========================
#include "rt.h"

void cretae_subscriber_thread();


extern rt_table_t *
publisher_get_rt_table()

static void
test_cb(void *args,size_t args_size, nfc_op_t nfc_op_code, unit32_t client_id){

	 // this function is in subscriber but will be called by publisher

	 printf("%s() client: %u, notified with opcode %s\n", __FUNCTION__, client_id,nfc_get_str_op_code(nfc_op_code));
}

static void *
subscriber_thread_fn(void *args){
	rt_entry_keys_t rt_entry_keys;
	memset(&rt_entry_keys, 0, sizeof(re_entry_keys_t));
	strncpy(rt_entry_keys.dest, "122.1.1.1", 16);
	rt_entry_keys.amsk = 32;

	//rt_table_register for_notification(....)

	pause();
	return NULL;
}

void cretae_subscriber_thread(unit32_t client_id){  //unit32 is unsigned integer value

	pthread_attr_t attr;
	pthread_t subs_thread;

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

	pthread_create(&subs_thread, &attr, subscriber_thread_fn,(void *)client_id);
	printf("subscriber %u created \n", client_id);
}

__________________________________________________________________________________________________________________________________________________________

S6E10


	==>we will be allowing subscriptions

	Notification
		==>notify subscribers

__________________________________________________________________________________________________________________________________________________________

S6E12
//implementation of subscription process

rt.c

	void rt_table_register_for_notification(
	rt_table_t *rt_table,
	rt_entry_keys_t *key,
	size_t key_size,
	nfc_app_cb app_cb,
	unit32_t subs_id
	){
	
	bool new_entry_created;
	rt_entry_t *rt_entry;
	notif_chain_elem_t nfce;

	new_entry_created = false;

	rt_entry = rt_look_up_rt_entry(rt_table, key->dest, key->mask);
	
	if(!rt_entry){
	
	rt_entry = rt_add_or_update_rt_entry(
	
		rt_table, key->dest, key->mask, 0, 0);
		new_entry_created = true;
	}
	memset(&nfce, 0, sizeof(notif_chain_elem_t));

	assert(key_size <= MAX_NOTIF_KEY_SIZE);

	nfce.app_cb = app_cb;
	nfce.subs_id = subs_id;
	nfc_register_notif_chain(rt_entry->nfc, &nfce);

	if(!new_entry_create){
	app_cb(rt_entry, sizeof(rt_entry_t), NFC_ADD, subs_id);
	}

	//NFC_ADD is code to notify subscriber

	}


__________________________________________________________________________________________________________________________________________________________

S6E13

Implementing Notification

//notif.c

nfc_invoke_notif_chain()

.
.
.
//after adding entry 

if(gw_ip || oif) {

	nfc_invoke_notif_chain(rt_entry->nfc, (char *)rt_entry, sizeof(rt_entry_t), 0, 0, NFC_MOD);

}


bool rt_delete_rt_entry(.....){

rt_entry_remove(rt_table, rt_entry);
nfc_invoke_notif_chain(rt_entry->nfc, (char *)rt_entry, sizeof(rt_entry_t), 0, 0, NFC_DEL);
nfc_delete_all_nfce(rt_entry->nfc);
free(rt_entry->nfc);
rt_entry->nfc = NULL;
free(rt_entry);
return true;



}


__________________________________________________________________________________________________________________________________________________________

S6E14

	==>summary and output of interthread communication


__________________________________________________________________________________________________________________________________________________________

S7E1

	Thread cancellation

		==>you may want to cancel search on going operation

		==>you may want to stop sending periodic packets

		==>you may want to stop downloading the file

	==>Who cancels the thread

		==>other thread cancels other thread

		==>once the thread is cancelled, it is terminated
__________________________________________________________________________________________________________________________________________________________

S7E2

	types of cancellation
		
		==>Asynchrous cancellation

			==>there were so drawbacks of asynchronous cancellation

			pthread_cancel()  =>api to use cancel request

			==>cancel request (CR) is queued by OS

				==>then OS looks for opportunity to cancel

				==>this is why it is called asynchronous cancellation

__________________________________________________________________________________________________________________________________________________________

S7E3

	mastel_slave1.c

program to create 5 thread, where all thread writes string to thread_x.txt, where x is thread id

	==>thread handles are used to cancel threads

	==>Deferred Cancellation

__________________________________________________________________________________________________________________________________________________________

S7E4

master_slave_asynch_cancelaation.h


case 1:
	pthread_cancel(slave[thread_num]);
	break;  //might not cancel immediately
		//and must be cacellable threads


//////////////////////////

//cancellable thread

thread_fn(void *arg){

pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);

	//mode of cancel ==>asynch and defer

pthread_setcanceltype( PTHREAD_CANCEL_ASYNCHRONOUS, 0); //it is asynchronous


}

=================================================================================

>>> ./master_slave_asynch

__________________________________________________________________________________________________________________________________________________________

S7E5

thread asynchronous problem

	==>leave steering wheen while driving a car

		==>resource leaking
			==>file not closed may be
			==>sockets may  be in turn on position
				solution
					==>cleanup handlers
						

		==>cause invariants
			solution 
				==>cancellation points
		==>deadlocks

__________________________________________________________________________________________________________________________________________________________

S7E6

	Invariant problem ==>when thread is cancelled asynchronously

		==>a data structure in inconsistent state 

			==>suppose doubly linked list

				==>removing nodes
				==>adjusting pointers
					==>if cancelled in between ==>we will have another scene

			==>like in balanced tree
				(red tree or AVL tree)

__________________________________________________________________________________________________________________________________________________________

S7E7

Thread cancellation may lead to deadlock

	if mutex is locked and thread got cancelled

	==>Asynchronous cancellation prolem

		==>Resource leaking

		==>invariants

		==>deadlock


__________________________________________________________________________________________________________________________________________________________

S7E8


	thread cancellation ==>and give chance to clean up

		==>Thread clean up handlers

		==>void (*cleanup_handlers)(void *);

//master_slave_asynch_threadup_cleaner.c

thread_fn(){
	pthread_cleanup_push(f1,arg); //f1 is pointer to cleanup function, arg is ptr to memory passed to this f1 fn
		// all these push will go to stack ==>a and execute when we get cancellation 

	pthread_cleanup_pop(0); // as developer you dont have to pop from stack
}


__________________________________________________________________________________________________________________________________________________________

S7E9

master_slave_asynch_threadup_cleaner.c


void memory_cleanup_handler(void *args)

void * write_into_file(void *args){
...
...

int *thread_id = (int *)arg;
pthread_cleanup_push(memory_cleanup_handler, arg);

FILE *fptr = fopen(file_name, "w");

pthread_cleanup_push(file_cleanup_handler, fptr);



}


__________________________________________________________________________________________________________________________________________________________

S7E10

usage of cleanup handlers

pthread_cleanup_push(f1, arg);

		//>it is macro that means at compile time more code is added with open parethesis

unbalaced of push pop leads to error

pthread_exit(0);  // it invokes clean up activity

OR

goto cleanup:


cleanup:

	pthread_cleanup_pop(1);

__________________________________________________________________________________________________________________________________________________________

S8E1

	Deferred cancellation
		
		==>programmer has full control to cancel

		==>used to handle problem of invariant

		==>now that points are called cancellation points

	pthread_testcancel()


__________________________________________________________________________________________________________________________________________________________

S8E2

master_slave1_deferred_cancellation.c

pthread_setcanceltype( PTHREAD_CANCEL_DEFERRED, 0);



while(1){
len = sprintf(....); //danger function as it is dealing with buffer
fwrite(...)

pthread_testcancel(); // now it will be checking for thread cancellation at this line everytime
}

__________________________________________________________________________________________________________________________________________________________

S9E1

Listener threads

	==>threads need to listen external events

__________________________________________________________________________________________________________________________________________________________

S9E2

listener_main.exe

pkt_recv_fn(char *pkt){
	/* process pkt p */
}


__________________________________________________________________________________________________________________________________________________________

S9E3

	pkt recvd via UDP


__________________________________________________________________________________________________________________________________________________________

S9E4

#include<stdint.h>
#include "network_utils.h"


void pkt_rcv_fn(
char *pkt,
uint32_t pkt_size,
char *sender_ip,
uint32_t port_no){
	
	printf("%s() : pkt recvd =%s, pkt size = %u\n",__FUNCTION__, pkt, pkt_size);
}

pthread_t *listener1 = NULL;
pthread_t *listener2 = NULL;

int main(int argc, char **argv){
	
	printf("Listening on UDP port no. 3000\n");
	listener1 = udp_server_create_and_start("127.0.0.1",3000,pkt_rcv_fn);

	
	printf("Listening on UDP port no. 3001\n");
	listener2 = udp_server_create_and_start("127.0.0.1",3001,pkt_rcv_fn);

	pthread_exit(0);
	return 0;
}


__________________________________________________________________________________________________________________________________________________________

S10E1



	





	....incomp








+====+===============================================================================================================================================================


C/C++ multiple compilation and make file

================================================


//https://medium.com/coding-blocks/make-and-cmake-automating-c-build-process-900f569a75db


Make and CMake : Automating C++ Build Process
Deepak Aggarwal
Deepak Aggarwal
Follow
Dec 13, 2017 · 3 min read





Many of my students struggle to understand the C++ compilation when applied to multiple files that belong to same project.
A C++ project, something that will give you one executable, can consists of multiple files. The number could be as large as 1000 for complex projects like Adobe Photoshop or Google Chrome.
Now, if I give you this source code, would you be able to compile it and get an executable that you can double click; and the software starts running??? This would be painful (if not difficult) even for an expert.
What about if I give you a list of instructions and a program, that can execute these instructions and do this compilation for you. The end product would be an executable. Isn’t it great. No! Its superb.
That is what we are going to learn here. How to write the instructions in a file that will be executed by a program to automate the build (or loosely compilation) process.
The file that we are going to write is named Makefile.
The program we are going to use is called make.
C++ Multi-file Programming
Let us consider a single program to divide 2 numbers. Files that we will require are :
div.h

2. div.cpp

3. main.cpp

If I want to compile these files and want to transform them into an exectable, i would write the following in terminal :
# Just translate the files.
# Result would be div.o main.o in the present working directory
g++ -c div.cpp
g++ -c main.cpp
# Do all the linking stuff
g++ div.o main.o -o divisonExecutable
Writing our Makefile
That’s lot to remember. Now let’s write an equivalent Makefile
Important : The statements starting with # are for humans and shall not be typed in the terminal. But do read them.
# Makefile
# Specify what I need in the end. One single executable
divisonExecutable : main.o div.o
# Read this as divisionExecutable depends on main.o div.o
# But how is it produced??? Hmm...using the below statement
    g++ main.o div.o -o divisonExecutable 
# starts with tab, I repeat tab
#-----------------------------------------------------------------
# But main.o is not there? So specify how it is produced.
main.o : main.cpp div.h
    g++ -c main.cpp
# Same for test.o
test.o : test.cpp test.h
    g++ -c test.cpp
So, we have written a Makefile that contain instruction to automate the compilation process. The program that understands this is make.
So simply write
make
Yup! Just make. make looks for makefile, if not found, Makefile.
If you need to specify your own file name, you need to specify
make -f name-of-my-file-that-make-will-use
When you will run make, you can see the following in your pwd.
test.o
main.o
divisonExecutable
If you want to learn more about make do visit these two articles which I found really helpful.



+====+===============================================================================================================================================================

Automating builds (youtube)

.c (source file)  ==> goes via preprocessor ==>compiler ==>will give .s file ==>goes through assembler==>gives object file

	==>goes through linker ===>and produces executable


//preprocessor handles header files and strip out comment
//compiler ==>(.c to assembly file)
//assembler -==>translates assembly to object file
//linker brings together object file to produce executables

clang file1.o file2.o -o executable -l m  //-l m id for like having all modules

//////////////////////////////////////

vim Makefile

#_*_ Makefile _*_

#target: dependencies
#	action


// if we use make ===>it will look for top most target

else use

all: target1 target2

target1: target1.o target1_1.o target1_2.h
	gcc target1.o target1_1.o -o target1 -l m

target1.o: target1.c
	gcc -c target1.c

target1_1.o: target1_1.c
	gcc -c target1_1.c


// same goes for target 2

clean:
	rm -f *.o target1 target2 ...

//we can also use 

>>>make target2 //in this case compilation will start from target2

//make only looks for changes

//change in header file can also make recompile

// tab is needed, no space

==================================================================================================

function pointer in C

//https://www.youtube.com/watch?v=TpIuj3Lgho0&list=PLnpfWqvEvRCchcCM-373x2630drhtdWEw&index=9

	==>function is block of instruction

name of the function is itself an address ==>you dont have to use & , though you can use it

==>

to assign a function to a variable

int (*var)(int x) = foo;

// bubble sort ==>in bubble sort in first iteration the largest element is positiones at last of  array
// compare with succesive and swap if no. is larger with its successive elements

===>

strcmp ==>return positive if, first string comes after second string
	==>0 if both are equal
	==>otherwise -1

#include<stdlib.h> ==>>for malloc

//man memcpy

memcpy(src_addr, dest_addr, size);

33:00 min   ....incomp


















++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

file handlinig in c

__________________________________________________________________________
E3 (https://www.youtube.com/watch?v=7htwsHi60BA&list=PL9FuOtXibFjVzB2Bm8WalF_SZcIhpZB6X&index=4)

#include<stdio.h>

fp = fopen("file_location",mode);  //mode = "r" | "w"
fprintf(file_pointer,"message %d",_int); //file pointer = fp

do{

fprintf(fp,"dfsdfds");
}while(condn);

fclose(file_pointer);

}

__________________________________________________________________________
E4 

rewind(fp);  // will put cursor to begining of file

__________________________________________________________________________
E5

char ch[100];

while(fscanf(fp,"%s",&a)!=EOF){

sscanf(a,"%d",&x);  ==>return boolean if string can be coverted to  integer

}


__________________________________________________________________________
E6

fprintf(....) => to put string in file

fscanf(....) => to read string from file


		.....done
__________________________________________________________________________





